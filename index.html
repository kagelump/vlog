<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Classification Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar styling for the results container */
        .results-container::-webkit-scrollbar {
            width: 8px;
        }
        .results-container::-webkit-scrollbar-thumb {
            background-color: #6366f1; /* Indigo-500 */
            border-radius: 4px;
        }
        .results-container::-webkit-scrollbar-track {
            background: #f1f5f9; /* Slate-100 */
        }
        .text-shadow {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        /* Custom styling for the clickable thumbnail (video poster) */
        .video-poster {
            transition: transform 0.2s;
        }
        .video-poster:hover {
            transform: scale(1.01);
            opacity: 0.95;
        }
        
        /* Ensure table rows respect the left border for scene coloring */
        #results-table tbody tr {
            transition: all 0.3s ease-in-out;
        }
        #results-table tbody tr:hover {
            filter: brightness(1.02);
        }

        /* Styling for the Keep/Discard toggle button */
        .keep-toggle {
            transition: background-color 0.2s, transform 0.1s;
        }
        .keep-toggle:active {
            transform: scale(0.98);
        }
        
        /* Styling for the quick set duration buttons */
        .quick-set-btn {
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            transition: background-color 0.1s, transform 0.1s;
        }
        .quick-set-btn:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
        .quick-set-btn:active {
            transform: scale(0.98);
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    
    <!-- Changed from container mx-auto to w-full to maximize horizontal space -->
    <div class="w-full p-4 sm:p-8">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl sm:text-5xl font-extrabold text-indigo-700 text-shadow mb-2">
                Classification Results Monitor
            </h1>
            <p id="status-message" class="text-gray-600 text-lg transition-all duration-500">
                <span class="font-semibold text-green-500">Live:</span> Fetching data every 60 seconds...
            </p>
        </header>

        <!-- Results Table Container -->
        <div class="bg-white shadow-2xl rounded-xl overflow-hidden ring-4 ring-indigo-200/50">
            <div class="p-6 bg-indigo-50 border-b border-indigo-100 flex justify-between items-center">
                <h2 class="text-2xl font-semibold text-indigo-800">Latest Video Analyses (Clustered by Scene)</h2>
                <span id="last-updated" class="text-sm font-medium text-indigo-500"></span>
            </div>
            
                        <div class="overflow-x-auto results-container">
                <table id="results-table" class="min-w-full border-collapse">
                    <thead>
                        <tr class="bg-indigo-100">
                            <th class="px-4 py-3 text-left text-sm font-semibold text-indigo-900 w-32">Thumbnail</th>
                            <th class="px-4 py-3 text-left text-sm font-semibold text-indigo-900">File</th>
                            <th class="px-4 py-3 text-left text-sm font-semibold text-indigo-900">Description</th>
                            <th class="px-4 py-3 text-center text-sm font-semibold text-indigo-900 w-24">Type</th>
                            <th class="px-4 py-3 text-center text-sm font-semibold text-indigo-900 w-24">Status</th>
                            <th class="px-4 py-3 text-center text-sm font-semibold text-indigo-900 w-24">Length</th>
                            <th class="px-4 py-3 text-center text-sm font-semibold text-indigo-900 w-24">Cut</th>
                            <th class="px-4 py-3 text-center text-sm font-semibold text-indigo-900 w-32">Last Updated</th>
                        </tr>
                    </thead>
                    <tbody id="table-body">
                        <!-- Rows will be dynamically inserted here -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Footer / Instructions -->
        <footer class="mt-8 text-center text-gray-500 text-sm">
            <p>Clips are ordered by **timestamp (Earliest at Top)** and grouped into a single "Scene" if their timestamps are within 30 minutes of each other.</p>
            <p>This dashboard auto-updates every 60 seconds using a lightweight metadata-only endpoint.</p>
            <p>To run the server, save all three files (`video_classification_db.py`, `app.py`, and `index.html`) in the same directory, and then execute: <code class="bg-gray-200 p-1 rounded">python app.py</code></p>
        </footer>
    </div>
    
    <!-- Fullscreen Modal for Video Playback/Thumbnail View -->
    <div id="thumbnail-modal" class="fixed inset-0 z-50 bg-black bg-opacity-80 hidden items-center justify-center p-4 transition-opacity duration-300" onclick="closeModal()">
        <!-- Modal Size Increased to max-w-6xl. CHANGED overflow-hidden to overflow-y-auto to allow scrolling. -->
        <div class="bg-white rounded-lg shadow-2xl max-w-6xl w-full max-h-[95vh] overflow-y-auto" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center p-4 border-b border-gray-200 bg-gray-50">
                <h3 id="modal-title" class="text-xl font-semibold text-indigo-800 truncate"></h3>
                <button onclick="closeModal()" class="text-gray-400 hover:text-gray-600 p-2 rounded-full hover:bg-gray-200 transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <!-- Modal Content: Two columns for Video/Image and Metadata -->
            <div class="p-4 flex flex-col md:flex-row gap-6">
                <!-- Left Column: Video Player - md:w-2/3 (66% width) -->
                <div class="md:w-2/3 flex flex-col justify-center items-center p-2 bg-gray-100 rounded-lg">
                    <!-- VIDEO PLAYER ELEMENT - NOTE: Autoplay is omitted here to prevent automatic playback. -->
                    <video id="modal-video" controls class="max-w-full max-h-[80vh] object-contain rounded-md shadow-lg w-full h-auto" style="display: none;"></video>
                    <!-- FALLBACK IMAGE/POSTER ELEMENT -->
                    <img id="modal-image" src="" alt="Thumbnail/Poster" class="max-w-full max-h-[80vh] object-contain rounded-md shadow-lg" style="display: none;">
                    <div id="video-message" class="p-4 text-sm text-center text-gray-500" style="display: none;"></div>
                </div>
                <!-- Right Column: Details - md:w-1/3 (33% width) -->
                <div class="md:w-1/3 p-2 space-y-3 text-sm">
                    <h4 class="text-lg font-bold text-indigo-700 border-b pb-1">Video Metadata</h4>
                    
                    <div class="text-xs text-gray-500">
                        <span class="font-semibold text-gray-600">Original File:</span>
                        <span id="modal-filename" class="ml-1 font-medium text-gray-700 truncate block"></span>
                    </div>

                    <div id="modal-short-desc" style="display: none;" class="text-base font-semibold text-gray-800"></div>

                    <!-- Clip Type, Length, Timestamp, AND Scene Indicators Row -->
                    <div class="flex flex-wrap items-center gap-x-4 gap-y-2 mb-4">
                        <div id="modal-clip-type" class="text-xs px-3 py-1 font-medium rounded-full"></div>
                        <div id="modal-length" class="text-sm font-medium text-indigo-600"></div>
                        <div id="modal-timestamp" class="text-sm text-gray-500"></div>
                        
                        <!-- SCENE INDICATORS -->
                        <div id="scene-indicator-start" style="display: none;" class="px-3 py-1 text-xs font-bold rounded-full bg-rose-100 text-rose-700 border border-rose-400">START OF SCENE</div>
                        <div id="scene-indicator-end" style="display: none;" class="px-3 py-1 text-xs font-bold rounded-full bg-cyan-100 text-cyan-700 border border-cyan-400">END OF SCENE</div>
                    </div>
                    
                    <!-- NEW: EDITING DECISIONS SECTION with INTERACTIVE CONTROLS -->
                    <h4 class="text-lg font-bold text-indigo-700 border-b pb-1 mt-4">Editing Decisions</h4>
                    <div class="space-y-4">
                        <!-- KEEP / DISCARD Toggler -->
                        <div class="flex flex-col gap-2">
                            <span class="font-semibold text-gray-600">Action:</span>
                            <button id="toggle-keep-btn" 
                                class="keep-toggle px-4 py-2 text-sm font-bold rounded-lg shadow-md hover:shadow-lg transition">
                                Toggle Status
                            </button>
                            <!-- Visual status indicator (text updated by JS) -->
                            <div id="modal-keep-status" class="px-3 py-1 text-xs font-bold rounded-full text-center"></div>
                        </div>

                        <!-- CLIP CUT DURATION Input -->
                        <div class="flex flex-col gap-2">
                            <div class="flex items-center justify-between">
                                <span class="font-semibold text-gray-600">Cut Length (Seconds):</span>
                                <span id="modal-cut-source" class="text-xs text-gray-400"></span>
                            </div>
                            
                            <!-- Quick Set Buttons (2s, 4s, 8s, 16s, FULL) -->
                            <div id="quick-set-buttons" class="grid grid-cols-5 gap-1.5">
                                <button type="button" data-duration="2" data-key="q" class="quick-set-btn bg-gray-200 text-gray-800 p-1 rounded-lg text-xs font-semibold hover:bg-indigo-100 transition">2s (Q)</button>
                                <button type="button" data-duration="4" data-key="w" class="quick-set-btn bg-gray-200 text-gray-800 p-1 rounded-lg text-xs font-semibold hover:bg-indigo-100 transition">4s (W)</button>
                                <button type="button" data-duration="8" data-key="e" class="quick-set-btn bg-gray-200 text-gray-800 p-1 rounded-lg text-xs font-semibold hover:bg-indigo-100 transition">8s (E)</button>
                                <button type="button" data-duration="16" data-key="r" class="quick-set-btn bg-gray-200 text-gray-800 p-1 rounded-lg text-xs font-semibold hover:bg-indigo-100 transition">16s (R)</button>
                                <button type="button" data-duration="full" data-key="t" class="quick-set-btn bg-indigo-100 text-indigo-700 p-1 rounded-lg text-xs font-bold hover:bg-indigo-200 transition">FULL (T)</button>
                            </div>

                            <!-- Custom Input Area -->
                            <div class="flex gap-2 mt-2">
                                <input id="cut-duration-input" type="number" step="0.1" min="0" 
                                       placeholder="Enter custom seconds (0 for full video)"
                                       class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                                <button id="save-duration-btn" 
                                    class="bg-indigo-500 text-white px-3 py-2 text-sm font-medium rounded-lg hover:bg-indigo-600 transition disabled:opacity-50"
                                    disabled>
                                    Save Custom
                                </button>
                            </div>
                            <p id="modal-cut-duration-info" class="text-xs text-gray-500 mt-1"></p>
                        </div>
                    </div>
                    
                    <!-- Long Description -->
                    <div class="pt-2 border-t mt-3">
                        <h5 class="text-sm font-semibold text-gray-600 mb-1">Full Description</h5>
                        <!-- Removed max-h-40 and overflow-y-auto to allow full expansion -->
                        <p id="modal-long-desc" class="text-xs text-gray-600 p-1 border rounded bg-gray-50"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const tableBody = document.getElementById('table-body');
        const lastUpdatedEl = document.getElementById('last-updated');
        const statusEl = document.getElementById('status-message');
        
        const modal = document.getElementById('thumbnail-modal');
        const modalVideo = document.getElementById('modal-video');
        const modalImage = document.getElementById('modal-image');
        const modalTitle = document.getElementById('modal-title');
        const videoMessage = document.getElementById('video-message');
        
        const modalFilename = document.getElementById('modal-filename');
        const modalShortDesc = document.getElementById('modal-short-desc');
        const modalLongDesc = document.getElementById('modal-long-desc');
        const modalClipType = document.getElementById('modal-clip-type');
        const modalLength = document.getElementById('modal-length');
        const modalTimestamp = document.getElementById('modal-timestamp');
        
        // Scene Indicator Elements
        const sceneStartIndicator = document.getElementById('scene-indicator-start');
        const sceneEndIndicator = document.getElementById('scene-indicator-end');

        // Editing Decision Elements and Controls
        const modalKeepStatus = document.getElementById('modal-keep-status');
        const toggleKeepBtn = document.getElementById('toggle-keep-btn');
        const cutDurationInput = document.getElementById('cut-duration-input');
        const saveDurationBtn = document.getElementById('save-duration-btn');
        const modalCutDurationInfo = document.getElementById('modal-cut-duration-info');
        const modalCutSource = document.getElementById('modal-cut-source');
        const quickSetButtonsContainer = document.getElementById('quick-set-buttons'); 

        // Global state for navigation and current file context
        let currentResults = []; // This will now hold metadata *without* thumbnails
        let currentIndex = -1;
        let currentFilename = null;

        // Map for keyboard shortcuts
        const durationKeyMap = {
            'q': 2,
            'w': 4,
            'e': 8,
            'r': 16,
            't': 'full'
        };

        // --- SCENE CLUSTERING CONFIGURATION ---
        const THRESHOLD_MS = 30 * 60 * 1000; // 30 minutes in milliseconds
        const SCENE_COLORS = [
            'border-l-4 border-rose-500 bg-rose-50/70',
            'border-l-4 border-indigo-500 bg-indigo-50/70',
            'border-l-4 border-green-500 bg-green-50/70',
            'border-l-4 border-amber-500 bg-amber-50/70',
            'border-l-4 border-purple-500 bg-purple-50/70',
            'border-l-4 border-cyan-500 bg-cyan-50/70',
        ];

        /**
         * Converts ISO timestamp (from SQLite) into a human-readable format.
         */
        function formatTimestamp(isoString) {
            if (!isoString) return 'N/A';
            const date = new Date(isoString);
            // Format as YYYY-MM-DD HH:MM:SS
            return date.toLocaleDateString('en-US', { year: 'numeric', month: '2-digit', day: '2-digit' }) + ' ' + 
                   date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
        }

        /**
         * Converts ISO timestamp to Unix milliseconds for calculations.
         */
        function getTimeInMs(isoString) {
            if (!isoString) return 0;
            return new Date(isoString).getTime();
        }

        /**
         * Converts seconds into MM:SS.S format (including one decimal place for cut precision).
         */
        function formatLength(totalSeconds) {
            if (typeof totalSeconds !== 'number' || isNaN(totalSeconds) || totalSeconds < 0) return 'N/A';
            // Round to 1 decimal point for display
            totalSeconds = parseFloat(totalSeconds.toFixed(1)); 
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            const remainder = totalSeconds % 1;
            
            let formatted = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            // If there's a decimal component (e.g., 420.5 seconds), add the decimal part
            if (remainder > 0) {
                 formatted += `.${String(Math.round(remainder * 10)).charAt(0)}`;
            }

            return formatted;
        }

        /**
         * Swaps the thumbnail for the video player and starts playback.
         */
        function playVideo() {
            // Only proceed if the modal is open and the image is marked as a poster
            if (modal.classList.contains('flex') && modalImage.classList.contains('video-poster')) {
                modalImage.style.display = 'none';
                modalVideo.style.display = 'block';
                modalImage.classList.remove('cursor-pointer', 'video-poster');
                
                // Start playback on user interaction
                modalVideo.play().catch(error => {
                    console.error("Error attempting to play video:", error);
                    // Provide feedback if playback fails
                    videoMessage.style.display = 'block';
                    videoMessage.textContent = 'Could not start video playback automatically.';
                });
            }
        }
        
        /**
         * Clears the modal, stops video playback, and hides the modal container.
         */
        function closeModal() {
            modal.classList.remove('flex');
            modal.classList.add('hidden');
            document.body.style.overflow = ''; // Restore background scrolling
            currentIndex = -1; // Reset index when closed
            currentFilename = null;
            modalVideo.pause(); // Stop video playback
            // Reset media display back to thumbnail/poster view
            modalVideo.style.display = 'none';
            modalImage.style.display = 'block';
            modalImage.classList.add('cursor-pointer', 'video-poster');
        }

        /**
         * Helper function to send POST requests to the new API endpoints.
         */
        async function sendUpdate(url, payload) {
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`Server error: ${response.statusText}`);
                }
                // Refresh the table using the lightweight endpoint to show the immediate update
                fetchResults(false); 
                return true;
            } catch (error) {
                console.error("Update failed:", error);
                return false;
            }
        }

        /**
         * Toggles the 'keep' status and updates the database.
         */
        async function sendKeepUpdate() {
            const result = currentResults[currentIndex];
            if (!result || !currentFilename) return;

            // Toggle the status: 1 -> 0, 0 -> 1
            const newKeepStatus = result.keep === 1 ? 0 : 1;
            
            toggleKeepBtn.disabled = true;
            toggleKeepBtn.textContent = 'Saving...';

            const success = await sendUpdate('/api/update_keep', { 
                filename: currentFilename, 
                keep: newKeepStatus 
            });

            if (success) {
                // Manually update the local data temporarily to reflect change immediately in the modal
                result.keep = newKeepStatus; 
                updateKeepStatusUI(result);
            } else {
                // Restore the UI state if saving fails
                updateKeepStatusUI(result); 
                console.error("Failed to toggle keep status.");
            }
            toggleKeepBtn.disabled = false;
        }

        /**
         * Handles updating the clip duration, either from a quick button or custom input.
         * @param {number|string|null} [durationValue] - If provided, uses this value (e.g., 2, 4, 8, 16, or 'full'). If null/undefined, uses input field value.
         */
        async function handleDurationUpdate(durationValue = undefined) {
            if (!currentFilename || currentIndex === -1) return;

            let duration = null;
            let source = '';

            if (durationValue !== undefined) {
                // Quick button/key press path
                if (durationValue === 'full' || durationValue === 0) {
                    duration = null;
                    source = 'Quick (FULL)';
                } else {
                    duration = parseFloat(durationValue);
                    source = `Quick (${durationValue}s)`;
                }
            } else {
                // Custom input path
                const inputValue = cutDurationInput.value.trim();
                if (inputValue === '') {
                    duration = null; // Reset to full video
                    source = 'Custom (FULL)';
                } else {
                    duration = parseFloat(inputValue);
                    if (isNaN(duration) || duration < 0) {
                        console.error('Invalid duration entered.');
                        return;
                    }
                    source = 'Custom';
                }
            }
            
            const originalLength = currentResults[currentIndex].video_length_seconds;
            if (duration !== null && duration > originalLength) {
                console.warn(`Duration ${duration}s exceeds video length ${originalLength}s. Setting to max length.`);
                duration = originalLength; 
                // Note: The UI for the input will be updated in updateCutDurationUI
            }

            // Set buttons/input state during submission
            saveDurationBtn.disabled = true;
            saveDurationBtn.textContent = 'Saving...';
            document.querySelectorAll('.quick-set-btn').forEach(btn => btn.disabled = true);

            const success = await sendUpdate('/api/update_duration', { 
                filename: currentFilename, 
                duration: duration 
            });

            if (success) {
                // Manually update the local data temporarily
                currentResults[currentIndex].clip_cut_duration = duration;
                updateCutDurationUI(currentResults[currentIndex], source);
            }
            
            // Restore buttons/input state
            saveDurationBtn.disabled = true; // Disable until custom input changes again
            saveDurationBtn.textContent = 'Save Custom';
            document.querySelectorAll('.quick-set-btn').forEach(btn => btn.disabled = false);
        }

        
        /**
         * Updates the visual state of the Keep/Discard controls in the modal.
         */
        function updateKeepStatusUI(result) {
            const isKeep = result.keep === 1;
            if (isKeep) {
                modalKeepStatus.textContent = 'Status: KEEP';
                modalKeepStatus.className = 'px-3 py-1 text-xs font-bold rounded-full text-center bg-emerald-100 text-emerald-800';
                toggleKeepBtn.textContent = 'Switch to DISCARD (D)';
                toggleKeepBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'text-white');
                toggleKeepBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white');
            } else {
                modalKeepStatus.textContent = 'Status: DISCARD';
                modalKeepStatus.className = 'px-3 py-1 text-xs font-bold rounded-full text-center bg-red-100 text-red-800';
                toggleKeepBtn.textContent = 'Switch to KEEP (D)';
                toggleKeepBtn.classList.remove('bg-green-500', 'hover:bg-green-600', 'text-white');
                toggleKeepBtn.classList.add('bg-red-500', 'hover:bg-red-600', 'text-white');
            }
        }

        /**
         * Updates the visual state of the Cut Duration controls in the modal.
         * @param {Object} result - The current video result object.
         * @param {string} [source='Initial'] - The source of the update (for display).
         */
        function updateCutDurationUI(result, source = 'load') {
            const cutDuration = result.clip_cut_duration;
            const originalLength = result.video_length_seconds;
            
            let displayDuration;
            let sourceText;
            let inputInitialValue = '';

            if (cutDuration !== null && cutDuration > 0 && cutDuration < originalLength) {
                displayDuration = formatLength(cutDuration) + 's';
                sourceText = `(Custom Cut, from ${source})`;
                inputInitialValue = cutDuration.toFixed(1);
            } else if (cutDuration !== null && cutDuration >= originalLength) {
                // Handle cases where duration was set to be >= original length (should be maxed out)
                 displayDuration = formatLength(originalLength) + 's';
                 sourceText = `(Full Length Used, from ${source})`;
                 inputInitialValue = originalLength.toFixed(1); // Show max value in the input field
            } else {
                displayDuration = formatLength(originalLength) + 's';
                sourceText = `(Full Length Used, from ${source})`;
                inputInitialValue = ''; // Empty input box for full length
            }
            
            modalCutDurationInfo.textContent = `Current Cut: ${displayDuration} (Original: ${formatLength(originalLength)}s)`;
            modalCutSource.textContent = sourceText;
            cutDurationInput.value = inputInitialValue;
            saveDurationBtn.disabled = true; // Disable save button until input changes
        }

        /**
         * Loads the data for a given index from the currentResults array and updates the modal content.
         */
        async function displayModalForIndex(index) {
            if (index < 0 || index >= currentResults.length) {
                return; // Index out of bounds
            }

            const result = currentResults[index];
            currentIndex = index; // Set global index for keyboard navigation
            currentFilename = result.filename; // Set global filename for updates
            
            const clipType = result.clip_type || 'Unclassified';
            const videoFilename = result.filename || ''; // Use result.filename directly as it's the identifier
            
            let rawBase64 = result.video_thumbnail_base64; // May be undefined/null from metadata endpoint
            let thumbnailSrc = 'https://placehold.co/56x32/cccccc/ffffff?text=LOADING...';

            // 1. --- Thumbnail Fetching (Optimized: Fetch only if missing) ---
            if (!rawBase64 && videoFilename) {
                try {
                    // Fetch thumbnail using the new dedicated endpoint
                    const thumbResponse = await fetch(`/api/thumbnail/${encodeURIComponent(videoFilename)}`);
                    if (thumbResponse.ok) {
                        const thumbData = await thumbResponse.json();
                        rawBase64 = thumbData.video_thumbnail_base64;
                        // Cache the thumbnail in the local result object so we don't fetch it again 
                        // while the user is navigating the modal.
                        result.video_thumbnail_base64 = rawBase64; 
                    }
                } catch (e) {
                    console.error("Failed to fetch thumbnail:", e);
                }
            }

            // Set final thumbnail source
            if (rawBase64) {
                 thumbnailSrc = `data:image/png;base64,${rawBase64}`;
            } else {
                thumbnailSrc = 'https://placehold.co/56x32/cccccc/ffffff?text=NO+IMG';
            }


            // 2. --- Modal Content Setup ---

            const formattedDate = formatTimestamp(result.video_timestamp);
            const formattedLength = formatLength(result.video_length_seconds);

            modalTitle.textContent = result.video_description_short;
            modalFilename.textContent = result.filename;

            // Media setup (video/image)
            if (videoFilename) {
                const videoUrl = `/video/${videoFilename}`;
                modalImage.src = thumbnailSrc;
                modalImage.style.display = 'block';
                // Only add the click-to-play class if there is a video
                modalImage.classList.add('cursor-pointer', 'video-poster'); 
                modalVideo.src = videoUrl;
                modalVideo.poster = thumbnailSrc;
                modalVideo.load(); 
                modalVideo.style.display = 'none';
                modalVideo.pause(); // Ensure it is paused on load
                videoMessage.style.display = 'none';
            } else {
                modalImage.src = thumbnailSrc;
                modalImage.style.display = 'block';
                modalImage.classList.remove('cursor-pointer', 'video-poster');
                modalVideo.style.display = 'none';
                modalVideo.pause(); 
                videoMessage.style.display = 'block';
                videoMessage.textContent = 'Video file path is missing or the file was not found on the server.';
            }

            // Classification Metadata Setup
            modalShortDesc.textContent = result.video_description_short; 
            // The following line has been updated to remove height constraint
            modalLongDesc.textContent = result.video_description_long;
            modalLength.textContent = `Original: ${formattedLength}s`;
            modalTimestamp.textContent = `Date: ${formattedDate}`;
            
            // Clip Type Styling
            let clipClass = 'bg-gray-100 text-gray-800';
            if (clipType.includes('Main')) {
                clipClass = 'bg-green-100 text-green-800';
            } else if (clipType.includes('B-Roll') || clipType.includes('Scenic')) {
                clipClass = 'bg-yellow-100 text-yellow-800';
            } else if (clipType.includes('Tutorial')) {
                clipClass = 'bg-blue-100 text-blue-800';
            }
            modalClipType.className = `text-xs px-3 py-1 font-medium rounded-full ${clipClass}`;
            modalClipType.textContent = clipType;

            // Scene Indicator Logic
            sceneStartIndicator.style.display = result.isFirstInScene ? 'block' : 'none';
            sceneEndIndicator.style.display = (result.isLastInScene && !result.isFirstInScene) ? 'block' : 'none';
            
            // Editing Decision Logic & UI Setup
            updateKeepStatusUI(result);
            updateCutDurationUI(result, 'load');


            // 3. Show Modal if not already visible
            if (modal.classList.contains('hidden')) {
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                document.body.style.overflow = 'hidden';
            }
        }


        /**
         * Renders the data into the HTML table body, applying scene clustering and calculating scene boundary flags.
         * @param {Array<Object>} results - List of classification result dictionaries (metadata only).
         */
        function renderTable(results) {
            // 1. Sort results by timestamp (ASCENDING order: earliest first)
            const sortedResults = results.sort((a, b) => {
                return getTimeInMs(a.video_timestamp) - getTimeInMs(b.video_timestamp);
            });

            // 2. Cluster Identification and Flagging Pass
            let currentSceneId = 0;
            let lastTimestampMs = 0;
            let sceneMap = []; // Stores { id: id, start: index, end: index }

            sortedResults.forEach((result, index) => {
                const currentTimestampMs = getTimeInMs(result.video_timestamp);
                const timeDiff = currentTimestampMs - lastTimestampMs;

                // Check for a scene break (time difference > threshold or it's the first clip)
                if (timeDiff > THRESHOLD_MS || index === 0) {
                    currentSceneId++;
                    
                    // Mark the end of the previous scene (unless it's the very first clip)
                    if (index > 0) {
                        sortedResults[index - 1].isLastInScene = true;
                    }
                    
                    // Mark the current clip as the start of the new scene
                    result.isFirstInScene = true;
                    result.isLastInScene = false; // Default for current clip
                    sceneMap.push({ id: currentSceneId, start: index, end: index });
                } else {
                    // Continuation of current scene
                    result.isFirstInScene = false;
                    result.isLastInScene = false;
                    sceneMap[sceneMap.length - 1].end = index;
                }

                // Store sceneId for coloring
                result.sceneId = currentSceneId;
                
                lastTimestampMs = currentTimestampMs;
            });

            // Handle the very last clip in the entire dataset, which is always the end of its scene
            if (sortedResults.length > 0) {
                sortedResults[sortedResults.length - 1].isLastInScene = true;
            }

            // Store the enriched results globally (Metadata only, thumbnails excluded)
            currentResults = sortedResults;
            tableBody.innerHTML = ''; // Clear existing rows

            if (currentResults.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="5" class="text-center py-12 text-gray-400 text-lg">No classification results found in the database.</td></tr>';
                return;
            }

            // 3. Render Table Rows
            currentResults.forEach((result, index) => {
                
                // Assign color class based on the scene index
                const sceneColorClass = SCENE_COLORS[(result.sceneId - 1) % SCENE_COLORS.length];

                // Add a visual separator when a new scene begins (for multi-clip scenes only)
                if (result.isFirstInScene && index > 0) {
                    const separatorRow = document.createElement('tr');
                    // Changed colspan to 5 since we now have 5 columns
                    separatorRow.innerHTML = `<td colspan="5" class="p-2 border-t-4 border-dashed border-gray-300 bg-gray-100 text-center text-xs font-semibold text-gray-500">--- Scene Break: Clips are over 30 minutes apart ---</td>`;
                    tableBody.appendChild(separatorRow);
                }

                // --- Rest of the rendering logic ---
                const clipType = result.clip_type || 'Unclassified';
                // Placeholder image for the table view since we skipped fetching the base64 data
                const thumbnailSrc = 'https://placehold.co/56x32/cccccc/ffffff?text=THUMB';
                
                const formattedDate = formatTimestamp(result.video_timestamp);
                
                // Determine styling for Clip Type
                let clipClass = 'bg-gray-100 text-gray-800';
                if (clipType.includes('Main')) {
                    clipClass = 'bg-green-100 text-green-800';
                } else if (clipType.includes('B-Roll') || clipType.includes('Scenic')) {
                    clipClass = 'bg-yellow-100 text-yellow-800';
                } else if (clipType.includes('Tutorial')) {
                    clipClass = 'bg-blue-100 text-blue-800';
                }
                
                // --- NEW COLUMN LOGIC: KEEP STATUS ---
                const isKeep = result.keep === 1;
                const keepText = isKeep ? 'KEEP' : 'DISCARD';
                const keepClass = isKeep ? 'bg-emerald-100 text-emerald-800' : 'bg-red-100 text-red-800';

                // --- NEW COLUMN LOGIC: CUT LENGTH ---
                const originalLength = result.video_length_seconds;
                const cutDuration = result.clip_cut_duration;
                
                const cutDisplay = (cutDuration === null || cutDuration >= originalLength)
                    ? 'FULL' 
                    : formatLength(cutDuration) + 's';
                
                const cutClass = cutDuration !== null && cutDuration < originalLength
                    ? 'font-bold text-red-500' // Highlight custom cut
                    : 'text-gray-500';

                const row = document.createElement('tr');
                // Apply the scene color and background class here
                row.className = `${sceneColorClass} hover:bg-opacity-90 transition-colors duration-200 border-b border-indigo-100`;
                
                // HTML for the table row (5 cells)
                row.innerHTML = `
                    <!-- 1. File Name / Thumbnail / Timestamp -->
                    <td class="px-6 py-4 text-sm text-gray-900">
                        <div class="flex items-center cursor-pointer thumbnail-trigger" 
                             data-index="${index}">
                            <!-- Using a placeholder image for speed, actual thumbnail fetched on click -->
                            <img src="${thumbnailSrc}" alt="Thumbnail" class="w-14 h-8 object-cover rounded mr-3 shadow">
                            <div>
                                <div class="font-medium truncate max-w-[200px]">${result.filename}</div>
                                <div class="text-xs text-gray-400 mt-0.5" title="Video Timestamp">${formattedDate}</div>
                            </div>
                        </div>
                    </td>
                    <!-- 2. Description cell (Responsive) - ADJUSTED FOR BOTTOM ALIGNMENT AND FULL WIDTH -->
                    <td class="px-6 py-4 hidden sm:table-cell whitespace-normal max-w-lg">
                        <div class="flex flex-col h-full justify-between">
                            <!-- Short Description (Top, truncated for space) -->
                            <div class="font-semibold text-sm text-gray-700 truncate mb-1">
                                ${result.video_description_short}
                            </div>
                            <!-- Long Description (Bottom, allows full width and line wrapping) -->
                            <div class="text-xs text-gray-500 w-full mt-auto">
                                ${result.video_description_long}
                            </div>
                        </div>
                    </td>
                    <!-- 3. Clip Type / Original Length -->
                    <td class="px-6 py-4 whitespace-nowrap">
                        <span class="px-3 py-1 inline-flex text-xs leading-5 font-semibold rounded-full ${clipClass}">
                            ${clipType}
                        </span>
                        <div class="text-xs font-semibold text-indigo-500 mt-1" title="Original Video Length">
                            ${formatLength(originalLength)}s (Orig)
                        </div>
                    </td>
                    <!-- 4. Keep Status (NEW COLUMN) -->
                    <td class="px-6 py-4 whitespace-nowrap text-center">
                        <span class="px-2 py-0.5 inline-flex text-xs font-medium rounded-full ${keepClass}">
                            ${keepText}
                        </span>
                    </td>
                    <!-- 5. Cut Length (NEW COLUMN) -->
                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm ${cutClass}">
                        ${cutDisplay}
                    </td>
                `;
                tableBody.appendChild(row);
            });
            
            // Update last fetched timestamp
            lastUpdatedEl.textContent = `Last fetched: ${formatTimestamp(new Date().toISOString())}`;
        }

        /**
         * Fetches data from the new lightweight API and updates the table.
         * @param {boolean} showLoading - If true, displays a loading message.
         */
        async function fetchResults(showLoading = true) {
            if (showLoading) {
                statusEl.innerHTML = '<span class="font-semibold text-blue-500">Loading Metadata...</span>';
            }
            try {
                // *** Using the new lightweight metadata endpoint ***
                const response = await fetch('/api/metadata'); 
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                renderTable(data);
                statusEl.innerHTML = '<span class="font-semibold text-green-500">Live:</span> Fetching data every 60 seconds...';

            } catch (error) {
                console.error("Failed to fetch classification results:", error);
                statusEl.innerHTML = '<span class="font-semibold text-red-500">Error:</span> Could not connect to server. Run `python app.py`.';
            }
        }

        // Initial fetch when the page loads
        fetchResults();

        // Set up the auto-update interval (60000ms = 60 seconds)
        const updateInterval = 60000;
        setInterval(fetchResults, updateInterval);
        
        // --- Event Delegation for Thumbnail Click in Table ---
        tableBody.addEventListener('click', (e) => {
            const trigger = e.target.closest('.thumbnail-trigger');
            if (trigger) {
                const index = parseInt(trigger.getAttribute('data-index'));
                displayModalForIndex(index);
            }
        });

        // --- Event Listener for Thumbnail Click inside Modal (Click-to-Play) ---
        modalImage.addEventListener('click', playVideo);
        
        // --- Event Listeners for Editing Controls ---
        toggleKeepBtn.addEventListener('click', sendKeepUpdate);

        // Delegation for the quick set duration buttons
        quickSetButtonsContainer.addEventListener('click', (e) => {
            const button = e.target.closest('.quick-set-btn');
            if (button) {
                const duration = button.getAttribute('data-duration');
                handleDurationUpdate(duration);
            }
        });

        // Event listener for the custom input field
        cutDurationInput.addEventListener('input', () => {
            const inputValue = cutDurationInput.value.trim();
            // Enable save button if input is non-empty, or explicitly 0 (which resets to full), 
            // and it's not obviously non-numeric (though parseFloat will handle this during save)
            saveDurationBtn.disabled = inputValue === '' ? false : isNaN(parseFloat(inputValue));
        });
        
        // Event listener for the custom save button
        saveDurationBtn.addEventListener('click', () => handleDurationUpdate());


        // --- Keyboard Navigation Handler ---
        document.addEventListener('keyup', (e) => {
            // Check if the modal is currently open and if there are results to navigate
            if (modal.classList.contains('flex') && currentResults.length > 0) {
                
                const key = e.key.toLowerCase(); // Define key here for all subsequent checks

                // 1. Navigation (Left/Right)
                if (e.key === 'ArrowRight') {
                    e.preventDefault(); // Prevent page scroll
                    const newIndex = (currentIndex + 1) % currentResults.length;
                    displayModalForIndex(newIndex);
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault(); // Prevent page scroll
                    const newIndex = (currentIndex - 1 + currentResults.length) % currentResults.length;
                    displayModalForIndex(newIndex);
                } else if (e.key === 'Escape') {
                    closeModal();
                }

                // 2. Keep/Discard Toggle (D)
                if (key === 'd') {
                    e.preventDefault();
                    sendKeepUpdate();
                }

                // 3. Quick Duration Update (Q, W, E, R, T)
                if (durationKeyMap.hasOwnProperty(key)) {
                    // Prevent key press from interfering with other elements
                    e.preventDefault(); 
                    const durationToSet = durationKeyMap[key];
                    // Call the unified update handler with the predefined duration
                    handleDurationUpdate(durationToSet);
                }
            }
        });

    </script>
</body>
</html>
